# C语言内存对齐

C语言中数据存放的方式是怎样的呢？是我们想象的那样一个变量接着一个变量存储的吗？阅读本章，你会知道答案。

## CPU对内存的访问
大家都知道一般CPU的数据总线都是32根，一个字节有8位。所以CPU一次可以读取4个字节的内存数据。为了使CPU具有更快读写内存的能力，CPU的设计限制了CPU从任意地址读取内存能力。比如CPU只能从4的倍数内存地址开始读取数据。比如一个int类型数据(0x11223344)，存放的内存地址为1000。

| 值   | 地址 |
| ---- | ---- |
| 0x11 | 1003 |
| 0x22 | 1002 |
| 0x33 | 1001 |
| 0x44 | 1000 |
因为1000是4的倍数，所以CPU可以一次性从内存中读取1000~1003地址的内容。
但如果0x11223344存放的内存地址为1002

| 值   | 地址 |
| ---- | ---- |
| 0x11 | 1005 |
| 0x22 | 1004 |
| 0x33 | 1003 |
| 0x44 | 1002 |
那么CPU必须先读取1000~1003之间的内存，然后再读取1004~1007之间的内存。然后再将第一次读取的后两个字节与第二次读取的前两个字节合并在一起成为我们需要的数据。这无疑极大的增加了CPU和内存的工作量，严重拖累程序的运行速度。因此C编译器使用了内存对齐技术来避免该问题。

## C变量内存对齐

我们先看一段代码
```c
#include<stdio.h>
int main(){
	char c = 'a';
	int i = 100;
	printf("%u",&c);
	printf("%u",&i);
}
//打印
1116132159
1116132152
```
这段代码可以重复运行多次，每次打印的结果都不一样。但是变量i的地址一定是4的倍数。这就是编译器采用了内存对齐的原因。

** 注意：变量的地址一定能整除该变量的字节长度 **

下面我们看一个例子，我们定义一个test的结构体，并打印test占用内存的大小
```c
#include<stdio.h>
struct test{
	char c1;
	int i;
	char c2;
};
int main(){
	printf("%d",sizeof(struct test));
}
//打印
12
```
一个char占用1个字节，一个int占用4个字节。那么一共应该占用1+4+1=6个字节，但是为什么打印12呢？我们看看变量在内存中的分布。

| 变量 | 地址      |
| ---- | --------- |
| 空   | 1009~1011 |
| c1   | 1008      |
| i    | 1004~1007 |
| 空   | 1001~1003 |
| c2   | 1000      |
c2存放在地址1000，因为i变量的内存对齐的原因，所以i只能存放在1004~1007。c1存放在1008，1001~1003内存空间被浪费了。

那么1000~1008只使用了9个字节，为什么sizeof操作会返回12呢？那是因为结构体test也要内存对齐。结构体结尾的字节是结构体中占用字节最多数的倍数。在test结构体中int i占用4个字节，所以结构体实际上占用的字节是1000~1011，一共占用12字节。


## 根据内存对齐规则优化数据存储顺序
我们理解了内存对齐的规则，那么可以根据该规则优化test结构体。代码如下
```c
#include<stdio.h>
struct test{
	char c1;
	char c2;
	int i;
};
int main(){
	printf("%d",sizeof(struct test));
}
//打印
8
```
同样一个结构体，我们修改结构体内部数据类型声明位置，可以降低结构体占用内存大小。我们画出结构体在内存分布状态

| 变量 | 地址      |
| ---- | --------- |
| 空   | 1005~1007 |
| c1   | 1005      |
| c2   | 1004      |
| i    | 1000~1003 |

因为c1和c2都是char（占用一个字节），所以c1和c2可以存放在任何能整除1的位置。所以c2存放在1004、c1可以存放在1005。1005~1007作为结构体test的内存对齐被浪费。
